package business_models

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joy095/identity/logger"
	"github.com/joy095/identity/models/business_image_models"
)

// Location represents geographical coordinates
type Location struct {
	Latitude  float64 `json:"latitude" binding:"min=-90,max=90"`
	Longitude float64 `json:"longitude" binding:"min=-180,max=180"`
}

// Business represents a business entity in your system.
type Business struct {
	ID         uuid.UUID `json:"id"`
	Name       string    `json:"name"`
	Category   string    `json:"category"`
	Address    string    `json:"address"`
	City       string    `json:"city,omitempty"`
	State      string    `json:"state,omitempty"`
	Country    string    `json:"country"`
	PostalCode string    `json:"postalCode,omitempty"`
	TaxID      string    `json:"taxId,omitempty"`
	About      string    `json:"about,omitempty"`
	Latitude   float64   `json:"latitude,omitempty"`
	Longitude  float64   `json:"longitude,omitempty"`
	// Latitude   float64                                `form:"latitude,omitempty"`
	// Longitude  float64                                `form:"longitude,omitempty"`
	CreatedAt time.Time                              `json:"createdAt"`
	UpdatedAt time.Time                              `json:"updatedAt"`
	IsActive  bool                                   `json:"isActive"`
	OwnerID   uuid.UUID                              `json:"ownerId"`
	PublicId  *string                                `json:"publicId"`
	Images    []*business_image_models.BusinessImage `json:"images,omitempty"`
}

// NewBusiness creates a new Business struct with a generated ID and initial timestamps.
func NewBusiness(
	name, category, address, city, state, country, postalCode, taxID,
	about, publicId string, lat, long float64, ownerUserID uuid.UUID) (*Business, error) {

	if name == "" {
		return nil, fmt.Errorf("business name is required")
	}
	if category == "" {
		return nil, fmt.Errorf("business category is required")
	}
	if address == "" {
		return nil, fmt.Errorf("business address is required")
	}
	if country == "" {
		return nil, fmt.Errorf("business country is required")
	}
	if ownerUserID == uuid.Nil {
		return nil, fmt.Errorf("valid owner ID is required")
	}

	now := time.Now()
	var publicIdPtr *string
	if publicId != "" {
		publicIdPtr = &publicId
	}

	return &Business{
		// ID will be generated by Postgres
		Name:       name,
		Category:   category,
		Address:    address,
		City:       city,
		State:      state,
		Country:    country,
		PostalCode: postalCode,
		TaxID:      taxID,
		About:      about,
		Latitude:   lat,
		Longitude:  long,
		CreatedAt:  now,
		UpdatedAt:  now,
		IsActive:   false,
		OwnerID:    ownerUserID,
		PublicId:   publicIdPtr,
	}, nil
}

// CreateBusiness inserts a new business record into the database.
func CreateBusiness(ctx context.Context, db *pgxpool.Pool, business *Business) (*Business, error) {
	query := `
        INSERT INTO businesses 
        (name, category, address, city, state, country, postal_code, tax_id, about, 
         location_latitude, location_longitude, created_at, updated_at, is_active, owner_id, public_id)
        VALUES 
        ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
        RETURNING id, name, category, address, city, state, country, postal_code, tax_id, 
                  about, location_latitude, location_longitude, created_at, updated_at, 
                  is_active, owner_id, public_id
    `

	err := db.QueryRow(ctx, query,
		business.Name,
		business.Category,
		business.Address,
		business.City,
		business.State,
		business.Country,
		business.PostalCode,
		business.TaxID,
		business.About,
		business.Latitude,
		business.Longitude,
		business.CreatedAt,
		business.UpdatedAt,
		business.IsActive,
		business.OwnerID,
		business.PublicId,
	).Scan(
		&business.ID,
		&business.Name,
		&business.Category,
		&business.Address,
		&business.City,
		&business.State,
		&business.Country,
		&business.PostalCode,
		&business.TaxID,
		&business.About,
		&business.Latitude,
		&business.Longitude,
		&business.CreatedAt,
		&business.UpdatedAt,
		&business.IsActive,
		&business.OwnerID,
		&business.PublicId,
	)

	if err != nil {
		logger.ErrorLogger.Errorf("Error creating business in DB: %v", err)
		return nil, err
	}
	return business, nil
}

// GetBusinessByID fetches a business record by its UUID ID (internal use).
func GetBusinessByID(ctx context.Context, db *pgxpool.Pool, id uuid.UUID) (*Business, error) {
	logger.InfoLogger.Infof("Attempting to fetch business with ID: %s", id)

	business := &Business{}
	query := `SELECT
	            b.id,
	            b.name,
	            b.category,
	            b.address,
	            b.city,
	            b.state,
	            b.country,
	            b.postal_code,
	            b.tax_id,
	            b.about,
	            b.location_latitude,
	            b.location_longitude,
	            b.created_at,
	            b.updated_at,
	            b.is_active,
	            b.owner_id,
				b.public_id
			FROM
				businesses AS b
			WHERE
				b.id = $1;
	`

	err := db.QueryRow(ctx, query, id).Scan(
		&business.ID,
		&business.Name,
		&business.Category,
		&business.Address,
		&business.City,
		&business.State,
		&business.Country,
		&business.PostalCode,
		&business.TaxID,
		&business.About,
		&business.Latitude,
		&business.Longitude,
		&business.CreatedAt,
		&business.UpdatedAt,
		&business.IsActive,
		&business.OwnerID,
		&business.PublicId,
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			logger.InfoLogger.Infof("Business with ID %s not found", id)
			return nil, fmt.Errorf("business not found")
		}
		logger.ErrorLogger.Errorf("Failed to fetch business %s: %v", id, err)
		return nil, fmt.Errorf("database error: %w", err)
	}

	logger.InfoLogger.Infof("Business with ID %s fetched successfully", id)

	// Fetch associated images for consistency with GetBusinessByPublicId
	images, err := business_image_models.GetImagesByBusinessID(ctx, db, business.ID)
	if err != nil {
		logger.ErrorLogger.Errorf("Failed to retrieve images for business ID %s: %v", id, err)
		business.Images = []*business_image_models.BusinessImage{}
	} else {
		business.Images = images
	}

	return business, nil
}

// GetBusinessIdOnly fetches a business record by its public ID (external use).
func GetBusinessIdOnly(ctx context.Context, db *pgxpool.Pool, publicId string) (uuid.UUID, error) {
	logger.InfoLogger.Infof("Attempting to fetch business with public ID: %s", publicId)

	var businessID uuid.UUID
	query := `SELECT id FROM businesses WHERE public_id = $1`

	err := db.QueryRow(ctx, query, publicId).Scan(&businessID)
	if err != nil {
		if err == pgx.ErrNoRows {
			logger.InfoLogger.Infof("Business with public ID %s not found", publicId)
			return uuid.Nil, fmt.Errorf("business not found") // Return uuid.Nil for not found
		}
		logger.ErrorLogger.Errorf("Failed to fetch business with public ID %s: %v", publicId, err)
		return uuid.Nil, fmt.Errorf("database error fetching business: %w", err) // Generic database error
	}

	logger.InfoLogger.Infof("Successfully fetched business ID: %s for public ID: %s", businessID, publicId)
	return businessID, nil
}

type BusinessCreatedAt struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

// GetBusinessCreatedAt fetches created_at and id for a business
func GetBusinessCreatedAt(ctx context.Context, db *pgxpool.Pool, businessID uuid.UUID) (*BusinessCreatedAt, error) {
	logger.InfoLogger.Infof("Attempting to fetch business with ID: %s", businessID)

	query := `
		SELECT id, created_at
		FROM businesses
		WHERE id = $1;
	`

	var bus BusinessCreatedAt
	err := db.QueryRow(ctx, query, businessID).Scan(
		&bus.ID,
		&bus.CreatedAt,
	)
	if err != nil {
		if err == pgx.ErrNoRows {
			logger.InfoLogger.Infof("No business found for ID: %s", businessID)
			return nil, nil
		}
		logger.ErrorLogger.Errorf("Failed to fetch business %s: %v", businessID, err)
		return nil, fmt.Errorf("database error fetching business: %w", err)
	}

	logger.InfoLogger.Infof("Business with ID %s fetched successfully", businessID)
	return &bus, nil
}

// GetBusinessByPublicId fetches a business record by its public ID (client-facing).
func GetBusinessByPublicId(ctx context.Context, db *pgxpool.Pool, publicId string) (*Business, error) {
	logger.InfoLogger.Infof("Attempting to fetch business with public ID: %s", publicId)

	business := &Business{}
	query := `SELECT
				id,
				name,
				category,
				address,
				city,
				state,
				country,
				postal_code,
				tax_id,
				about,
				location_latitude,
				location_longitude,
				created_at,
				updated_at,
				is_active,
				owner_id,
				public_id
			FROM
				businesses
			WHERE
				public_id = $1;
	`

	err := db.QueryRow(ctx, query, publicId).Scan(
		&business.ID,
		&business.Name,
		&business.Category,
		&business.Address,
		&business.City,
		&business.State,
		&business.Country,
		&business.PostalCode,
		&business.TaxID,
		&business.About,
		&business.Latitude,
		&business.Longitude,
		&business.CreatedAt,
		&business.UpdatedAt,
		&business.IsActive,
		&business.OwnerID,
		&business.PublicId,
	)

	if err != nil {
		if err == pgx.ErrNoRows {
			logger.InfoLogger.Infof("Business with public ID %s not found", publicId)
			return nil, fmt.Errorf("business not found") // More specific error for not found
		}
		logger.ErrorLogger.Errorf("Failed to fetch business with public ID %s: %v", publicId, err)
		return nil, fmt.Errorf("database error fetching business: %w", err) // Generic database error
	}

	// Now, fetch the associated images for this business
	images, err := business_image_models.GetImagesByBusinessID(ctx, db, business.ID)
	if err != nil {
		// Log the error but don't necessarily return it as a fatal error for GetBusinessByPublicId.
		// It's often acceptable to return a business even if its images can't be loaded,
		// especially if images are not always mandatory.
		logger.ErrorLogger.Errorf("Failed to retrieve images for business %s (ID: %s): %v", publicId, business.ID, err)
		// Initialize Images to an empty slice to avoid nil pointer dereferences
		business.Images = []*business_image_models.BusinessImage{}
	} else {
		business.Images = images
	}

	logger.InfoLogger.Infof("Business with public ID %s fetched successfully (including images)", publicId)
	return business, nil
}

func SearchBusinessModels(ctx context.Context, db *pgxpool.Pool, search string) ([]*Business, error) {
	logger.InfoLogger.Infof("Searching businesses by query: %s", search)

	// Escape special characters for ILIKE pattern
	search = strings.ReplaceAll(search, "\\", "\\\\")
	search = strings.ReplaceAll(search, "%", "\\%")
	search = strings.ReplaceAll(search, "_", "\\_")

	var businesses []*Business
	if search == "" {
		return businesses, nil
	}

	sql := `
        SELECT DISTINCT
            id,
            name,
            category,
            address,
            city,
            state,
            country,
            postal_code,
            tax_id,
            about,
            location_latitude,
            location_longitude,
            created_at,
            updated_at,
            is_active,
            owner_id,
            public_id,
            CASE 
                WHEN public_id ILIKE '%' || $1 || '%' THEN 1
                WHEN name ILIKE '%' || $1 || '%' THEN 2
                ELSE 3 
            END AS rank_score
        FROM businesses
        WHERE
            is_active = true
            AND (
                public_id ILIKE '%' || $1 || '%'
                OR name ILIKE '%' || $1 || '%'
                OR address ILIKE '%' || $1 || '%'
                OR city ILIKE '%' || $1 || '%'
                OR state ILIKE '%' || $1 || '%'
                OR country ILIKE '%' || $1 || '%'
                OR CONCAT_WS(', ', city, state, country) ILIKE '%' || $1 || '%'
            )
        ORDER BY rank_score, name ASC
        LIMIT 50;
    `

	rows, err := db.Query(ctx, sql, search)
	if err != nil {
		logger.ErrorLogger.Errorf("Database error during search for '%s': %v", search, err)
		return nil, fmt.Errorf("database error: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		business := &Business{}
		var rankScore int // <-- Temporary for ordering
		err := rows.Scan(
			&business.ID,
			&business.Name,
			&business.Category,
			&business.Address,
			&business.City,
			&business.State,
			&business.Country,
			&business.PostalCode,
			&business.TaxID,
			&business.About,
			&business.Latitude,
			&business.Longitude,
			&business.CreatedAt,
			&business.UpdatedAt,
			&business.IsActive,
			&business.OwnerID,
			&business.PublicId,
			&rankScore, // <-- consumed but not stored
		)
		if err != nil {
			logger.ErrorLogger.Errorf("Error scanning business row: %v", err)
			return nil, fmt.Errorf("row scan error: %w", err)
		}

		images, imgErr := business_image_models.GetImagesByBusinessID(ctx, db, business.ID)
		if imgErr != nil {
			logger.ErrorLogger.Errorf("Failed to load images for business %s: %v", business.ID, imgErr)
			business.Images = []*business_image_models.BusinessImage{}
		} else {
			business.Images = images
		}

		businesses = append(businesses, business)
	}

	if err = rows.Err(); err != nil {
		logger.ErrorLogger.Errorf("Row iteration error: %v", err)
		return nil, fmt.Errorf("iteration error: %w", err)
	}

	return businesses, nil
}

func GetSearchSuggestionsModel(ctx context.Context, db *pgxpool.Pool, query string) ([]string, error) {
	logger.InfoLogger.Infof("Fetching suggestions for query: %s", query)

	if query == "" {
		return []string{}, nil
	}

	var suggestions []string

	sql := `
        SELECT DISTINCT
            result_suggestion,
            -- Add the ordering expression so we can use it in ORDER BY
            CASE 
                WHEN result_suggestion ILIKE $1 || '%' THEN 1
                WHEN result_suggestion ILIKE '%' || $1 || '%' THEN 2
                ELSE 3 
            END AS match_type
        FROM (
            -- Suggestion 1: Business Name + Location
            SELECT
                name || ', ' || COALESCE(city, '') || ', ' || COALESCE(state, '') || ', ' || COALESCE(country, '') AS result_suggestion
            FROM businesses
            WHERE
                is_active = true
                AND (
                    name ILIKE '%' || $1 || '%'
                    OR city ILIKE '%' || $1 || '%'
                    OR state ILIKE '%' || $1 || '%'
                    OR country ILIKE '%' || $1 || '%'
                )

            UNION

            -- Suggestion 2: Public ID
            SELECT
                public_id AS result_suggestion
            FROM businesses
            WHERE
                is_active = true
                AND public_id ILIKE '%' || $1 || '%'

            UNION

            -- Suggestion 3: Location only (City, State, Country)
            SELECT
                COALESCE(city, '') || ', ' || COALESCE(state, '') || ', ' || COALESCE(country, '') AS result_suggestion
            FROM businesses
            WHERE
                is_active = true
                AND (
                    city ILIKE '%' || $1 || '%'
                    OR state ILIKE '%' || $1 || '%'
                    OR country ILIKE '%' || $1 || '%'
                )
        ) AS combined
        WHERE LENGTH(TRIM(result_suggestion)) > 3
        ORDER BY
            match_type,
            result_suggestion
        LIMIT 10;
    `

	rows, err := db.Query(ctx, sql, query)
	if err != nil {
		logger.ErrorLogger.Errorf("Database error fetching suggestions for '%s': %v", query, err)
		return nil, fmt.Errorf("db error: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var suggestion string
		var matchType int // <-- We scan it, but don't use it
		if err := rows.Scan(&suggestion, &matchType); err != nil {
			logger.ErrorLogger.Errorf("Error scanning suggestion: %v", err)
			continue
		}
		suggestions = append(suggestions, suggestion)
	}

	if err = rows.Err(); err != nil {
		logger.ErrorLogger.Errorf("Row iteration error: %v", err)
		return nil, fmt.Errorf("row error: %w", err)
	}

	return suggestions, nil
}

// GetBusinessByUserModel fetches all businesses for a given user ID.
func GetBusinessByUserModel(ctx context.Context, db *pgxpool.Pool, userID uuid.UUID) ([]*Business, error) {
	logger.InfoLogger.Infof("Attempting to fetch all businesses for user ID: %s", userID)

	var businesses []*Business
	query := `
        SELECT
            id,
            name,
            category,
            address,
            city,
            state,
            country,
            postal_code,
            tax_id,
            about,
            location_latitude,
            location_longitude,
            created_at,
            updated_at,
            is_active,
            owner_id,
            public_id
        FROM
            businesses
        WHERE
            owner_id = $1;
    `

	rows, err := db.Query(ctx, query, userID)
	if err != nil {
		logger.ErrorLogger.Errorf("Database error querying inactive businesses for user ID %s: %v", userID, err)
		return nil, fmt.Errorf("database error querying inactive businesses: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		business := &Business{}
		err := rows.Scan(
			&business.ID,
			&business.Name,
			&business.Category,
			&business.Address,
			&business.City,
			&business.State,
			&business.Country,
			&business.PostalCode,
			&business.TaxID,
			&business.About,
			&business.Latitude,
			&business.Longitude,
			&business.CreatedAt,
			&business.UpdatedAt,
			&business.IsActive,
			&business.OwnerID,
			&business.PublicId,
		)
		if err != nil {
			logger.ErrorLogger.Errorf("Error scanning business row for user ID %s: %v", userID, err)
			return nil, fmt.Errorf("error scanning business row: %w", err)
		}

		// Fetch associated images for each business
		images, err := business_image_models.GetImagesByBusinessID(ctx, db, business.ID)
		if err != nil {
			logger.ErrorLogger.Errorf("Failed to retrieve images for business ID %s: %v", business.ID, err)
			business.Images = []*business_image_models.BusinessImage{} // Ensure Images is an empty slice on error
		} else {
			business.Images = images
		}

		businesses = append(businesses, business)
	}

	if err := rows.Err(); err != nil {
		logger.ErrorLogger.Errorf("Error after iterating through rows for user ID %s: %v", userID, err)
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	if len(businesses) == 0 {
		logger.InfoLogger.Infof("No businesses found for user ID %s", userID)
		return []*Business{}, nil // Return an empty slice if no rows are found
	}

	logger.InfoLogger.Infof("Successfully fetched %d inactive businesses for user ID %s", len(businesses), userID)

	return businesses, nil
}

// UpdateBusiness updates an existing business record in the database.
func UpdateBusiness(ctx context.Context, db *pgxpool.Pool, business *Business) (*Business, error) {
	logger.InfoLogger.Infof("Attempting to update business record with ID: %s", business.ID)

	business.UpdatedAt = time.Now()

	query := `
        UPDATE businesses
        SET
            name = $2, category = $3, address = $4, city = $5, state = $6,
            country = $7, postal_code = $8, tax_id = $9, about = $10,
            location_latitude = $11, location_longitude = $12, updated_at = $13, is_active = $14
        WHERE
            id = $1
        RETURNING id`

	var id uuid.UUID
	err := db.QueryRow(ctx, query,
		business.ID,
		business.Name,
		business.Category,
		business.Address,
		business.City,
		business.State,
		business.Country,
		business.PostalCode,
		business.TaxID,
		business.About,
		business.Latitude,
		business.Longitude,
		business.UpdatedAt,
		business.IsActive,
	).Scan(&id)

	if err != nil {
		logger.ErrorLogger.Errorf("Failed to update business %s in database: %v", business.ID, err)
		return nil, fmt.Errorf("failed to update business: %w", err)
	}

	logger.InfoLogger.Infof("Business with ID %s updated successfully", business.ID)
	return business, nil
}

// DeleteImageAndReferences deletes an image and all its references
func DeleteImageAndReferences(ctx context.Context, db *pgxpool.Pool, imageID uuid.UUID) error {
	tx, err := db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction for image deletion: %w", err)
	}
	defer func() {
		if err := tx.Rollback(ctx); err != nil && !errors.Is(err, pgx.ErrTxClosed) {
			logger.ErrorLogger.Errorf("Failed to rollback transaction: %v", err)
		}
	}()

	// Delete from business_images table
	_, err = tx.Exec(ctx, `DELETE FROM business_images WHERE image_id = $1`, imageID)
	if err != nil {
		logger.ErrorLogger.Errorf("Failed to delete business image references for image %s: %v", imageID, err)
		return fmt.Errorf("failed to delete business image references: %w", err)
	}

	// Nullify the image_id in the 'services' table
	_, err = tx.Exec(ctx, `UPDATE services SET image_id = NULL WHERE image_id = $1`, imageID)
	if err != nil {
		logger.ErrorLogger.Errorf("Failed to nullify image_id in services table for image %s: %v", imageID, err)
		return fmt.Errorf("failed to nullify service image_id: %w", err)
	}

	// Delete the image record from the 'images' table
	res, err := tx.Exec(ctx, `DELETE FROM images WHERE id = $1`, imageID)
	if err != nil {
		logger.ErrorLogger.Errorf("Failed to delete image record %s: %v", imageID, err)
		return fmt.Errorf("failed to delete image record: %w", err)
	}

	if res.RowsAffected() == 0 {
		logger.WarnLogger.Warnf("Image with ID %s not found in images table for deletion.", imageID)
	} else {
		logger.InfoLogger.Infof("Successfully deleted image record %s from images table", imageID)
	}

	return tx.Commit(ctx)
}

func DeleteBusiness(ctx context.Context, db *pgxpool.Pool, businessID uuid.UUID) error {
	logger.InfoLogger.Infof("Attempting to delete business with ID: %s", businessID)

	query := `
        DELETE FROM businesses
        WHERE id = $1
        RETURNING id
    `

	var deletedID uuid.UUID
	err := db.QueryRow(ctx, query, businessID).Scan(&deletedID)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			logger.ErrorLogger.Errorf("Business with ID %s not found for deletion", businessID)
			return fmt.Errorf("business not found")
		}
		logger.ErrorLogger.Errorf("Database error deleting business with ID %s: %v", businessID, err)
		return fmt.Errorf("database error: %w", err)
	}

	logger.InfoLogger.Infof("Successfully deleted business with ID: %s", businessID)
	return nil
}

// GetAllBusinesses fetches all business records from the database, with optional pagination.
func GetAllBusinesses(ctx context.Context, db *pgxpool.Pool, limit, offset int) ([]*Business, error) {
	logger.InfoLogger.Info("Attempting to fetch businesses from database with pagination")

	businesses := []*Business{}

	baseQuery := `
        SELECT
            b.id,
            b.name,
            b.category,
            b.address,
            b.city,
            b.state,
            b.country,
            b.postal_code,
            b.about,
            b.location_latitude,
            b.location_longitude,
            b.public_id
        FROM
            businesses AS b
        WHERE b.is_active = true
        ORDER BY b.created_at DESC`

	query := baseQuery
	args := []interface{}{}
	placeholderNum := 1

	if limit > 0 {
		query += fmt.Sprintf(" LIMIT $%d", placeholderNum)
		args = append(args, limit)
		placeholderNum++
	}
	if offset > 0 {
		query += fmt.Sprintf(" OFFSET $%d", placeholderNum)
		args = append(args, offset)
		placeholderNum++
	}

	logger.InfoLogger.Infof("Executing query: %s with args: %v", query, args)

	rows, err := db.Query(ctx, query, args...)
	if err != nil {
		logger.ErrorLogger.Errorf("Failed to query businesses: %v", err)
		return nil, fmt.Errorf("failed to retrieve businesses: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		business := &Business{}
		err := rows.Scan(
			&business.ID,
			&business.Name,
			&business.Category,
			&business.Address,
			&business.City,
			&business.State,
			&business.Country,
			&business.PostalCode,
			&business.About,
			&business.Latitude,
			&business.Longitude,
			&business.PublicId,
		)
		if err != nil {
			logger.ErrorLogger.Errorf("Failed to scan business row: %v", err)
			return nil, fmt.Errorf("failed to scan business data: %w", err)
		}

		// Get full BusinessImage structs for the business using GetImagesByBusinessID
		// This function returns []*BusinessImage which includes ImageID and other struct fields
		images, err := business_image_models.GetImagesByBusinessID(ctx, db, business.ID)
		if err != nil {
			// Log the error but don't fail fetching the business list
			logger.WarnLogger.Warnf("Failed to get images for business %s: %v", business.ID, err)
			// business.Images will remain nil or empty
		} else {
			// Assign the retrieved images directly
			// The BusinessImage struct returned by GetImagesByBusinessID will have IsPrimary
			// populated from the database query. If you've also removed it from the
			// BusinessImage struct definition used by GetImagesByBusinessID, you would need
			// to adjust that function's scanning logic as well (similar to how GetAllImagesModel was adjusted).
			// Assuming GetImagesByBusinessID still populates IsPrimary correctly based on DB is_primary column:
			business.Images = images
		}

		businesses = append(businesses, business)
	}

	if err = rows.Err(); err != nil {
		logger.ErrorLogger.Errorf("Error after iterating rows for businesses: %v", err)
		return nil, fmt.Errorf("error during business row iteration: %w", err)
	}

	logger.InfoLogger.Infof("Fetched %d businesses successfully", len(businesses))
	return businesses, nil
}
